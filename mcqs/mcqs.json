[
  {
    "question": "Which MIPS register is hardwired to the value 0?",
    "options": [
      "sp",
      "x0",
      "at",
      "v0"
    ],
    "correct_answer": 2,
    "explanation": "The correct answer is B. x0. In MIPS architecture, register x0 is specifically hardwired to the value 0. This means that regardless of what operation is performed, reading from x0 will always return 0. It's commonly used in instructions where a zero value is needed without modifying other registers. A. sp (stack pointer) is used to point to the top of the stack in memory, facilitating function calls and local variable management; it is not hardwired to zero. C. at (assembler temporary) is a register reserved for the assembler to use during assembly; it is also not hardwired to zero and should not be used by user programs. D. v0 is used to store the return value of a function call; it is also not hardwired to zero and its value changes depending on the function's execution and return value. Therefore, only x0 is guaranteed to always hold the value 0, making option B the correct answer. ",
    "key_concept": "Registers",
    "question_type": "memorization"
  },
  {
    "question": "Consider a MIPS processor with a 5-stage pipeline (IF, ID, EX, MEM, WB) and standard data forwarding. A compiler is optimizing code for this processor. Which of the following statements is most accurate regarding instruction scheduling within a basic block?",
    "options": [
      "The compiler will only schedule instructions based on memory access patterns, ignoring other types of dependencies.",
      "The compiler can reorder instructions freely without considering data dependencies as the hardware handles all hazards.",
      "The compiler might reorder instructions within the basic block to minimize pipeline stalls, but must respect data dependencies.",
      "The compiler will always schedule instructions in the order they appear in the source code to maintain program correctness."
    ],
    "correct_answer": 3,
    "explanation": "Here's a detailed explanation of why option C is the correct answer and why the other options are incorrect: \n\n**C. The compiler might reorder instructions within the basic block to minimize pipeline stalls, but must respect data dependencies.** This is the most accurate statement. Instruction scheduling is a compiler optimization technique that aims to reorder instructions within a basic block to reduce pipeline stalls and improve performance. However, the compiler *must* respect data dependencies. Data dependencies occur when one instruction depends on the result of a previous instruction. Reordering instructions without considering these dependencies would lead to incorrect program execution.\n\nLet's examine why the other options are incorrect:\n\n**A. The compiler will only schedule instructions based on memory access patterns, ignoring other types of dependencies.** This is incorrect because instruction scheduling considers *all* types of dependencies (data, control, and structural), not just memory access patterns. Ignoring other dependencies would lead to incorrect code.\n\n**B. The compiler can reorder instructions freely without considering data dependencies as the hardware handles all hazards.** This is incorrect. While data forwarding in the hardware can mitigate some data hazards, it cannot resolve all of them. Some stalls might still be necessary, and more importantly, the compiler *must* ensure that the reordering does not violate fundamental data dependencies that forwarding cannot resolve. Unrestrained reordering would lead to incorrect results.\n\n**D. The compiler will always schedule instructions in the order they appear in the source code to maintain program correctness.** This is incorrect because it describes a situation with no optimization. While executing instructions in the original order guarantees correctness (assuming the original code is correct), it doesn't take advantage of potential performance improvements through instruction scheduling. A compiler's purpose is to improve performance while maintaining correctness. Therefore, this option doesn't reflect the behavior of an optimizing compiler.",
    "key_concept": "Instruction Set Architecture (ISA)",
    "question_type": "deep_understanding"
  },
  {
    "question": "In MIPS assembly, which memory segment is typically used for storing global variables and static data structures?",
    "options": [
      "Text segment",
      "Data segment",
      "Heap segment",
      "Stack segment"
    ],
    "correct_answer": 2,
    "explanation": "The correct answer is B. Data segment. Here's why:\n\nB. Data segment: This segment is specifically designed to store global variables, static variables, and other pre-initialized data that persists throughout the program's execution. These variables have a fixed memory location and are accessible from anywhere in the code.\n\nA. Text segment: The text segment, also known as the code segment, is used to store the program's executable instructions. It contains the compiled code that the processor executes. It is not used for storing variables.\n\nC. Heap segment: The heap is a region of memory used for dynamic memory allocation during program execution. Variables allocated on the heap are created and destroyed at runtime using functions like `malloc` and `free` (or their equivalents). It is not used for storing global variables.\n\nD. Stack segment: The stack is a region of memory used for storing local variables, function call information (like return addresses and parameters), and temporary data associated with function calls. The stack grows and shrinks as functions are called and return. It is not used for storing global variables.\n\nTherefore, the data segment is the appropriate choice for storing global variables and static data structures in MIPS assembly.",
    "key_concept": "Memory Organization",
    "question_type": "comprehension"
  },
  {
    "question": "Which addressing mode uses the register itself as the operand?",
    "options": [
      "Immediate Addressing",
      "Indirect Addressing",
      "Register Direct",
      "Displacement Addressing"
    ],
    "correct_answer": 3,
    "explanation": "The correct answer is C. Register Direct. In register direct addressing, the register itself holds the operand. The instruction specifies the register's name, and the CPU directly accesses the data stored in that register. For example, an instruction might be 'Move R1, R2', which copies the content of register R2 into register R1. Here, both R1 and R2 are directly accessed.  A. Immediate Addressing is incorrect because in immediate addressing, the operand is a constant value included directly in the instruction. B. Indirect Addressing is incorrect because in indirect addressing, the instruction specifies a register that contains the *address* of the operand, not the operand itself. The CPU must first access the register to get the address, and then access that memory location to get the operand. D. Displacement Addressing is incorrect because it involves adding a constant offset (displacement) to the contents of a register to calculate the memory address of the operand. It's a combination of direct and indirect addressing, but the register doesn't directly hold the operand; the register plus displacement holds the address of operand. Therefore, only Register Direct addressing uses the register itself as the operand",
    "key_concept": "Addressing Modes",
    "question_type": "memorization"
  },
  {
    "question": "Which MIPS assembly instruction is used to initiate a procedure call, saving the return address in $ra?",
    "options": [
      "jal (jump and link)",
      "j (jump)",
      "beq (branch if equal)",
      "jr (jump register)"
    ],
    "correct_answer": 1,
    "explanation": "The correct answer is A. jal (jump and link). The jal instruction is specifically designed to initiate a procedure call in MIPS assembly. It saves the address of the next instruction (the return address) in the register $ra (register 31) and then jumps to the target address specified in the instruction. This allows the program to execute the procedure and then return to the instruction following the jal instruction. B. j (jump) is incorrect because the j instruction performs a simple jump to a specified address without saving any return address. It is used for unconditional jumps within the program but not for procedure calls where a return is needed. C. beq (branch if equal) is incorrect as it is a conditional branch instruction. It compares two registers and branches to a specified address only if the registers are equal. It does not save any return address and is not used for procedure calls. D. jr (jump register) is incorrect because while it does jump to an address, the address is stored in a register. It's typically used to return from a procedure by jumping to the address stored in $ra, but it doesn't save the return address itself. The jal instruction is the only one that both jumps to the procedure and saves the return address in $ra. ",
    "key_concept": "Procedure Calls",
    "question_type": "memorization"
  }
]